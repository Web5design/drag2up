<script src="jquery.min.js"></script>
<script src="multipart.js"></script>
<script src="testing.js"></script>
<script src="hosts/imageshack.js"></script>
<script src="hosts/gist.js"></script>
<script src="hosts/pastebin.js"></script>
<script src="hosts/imgur.js"></script>
<script src="hosts/hotfile.js"></script>
<script src="hosts/cloudapp.js"></script>

<script src="hosts/dropbox/sha1.js"></script>
<script src="hosts/dropbox/oauth.js"></script>
<script src="hosts/dropbox/modern_dropbox.js"></script>
<script src="hosts/dropbox/dropbox.js"></script>
<script>


var filetable = {};

function params(obj){
  var str = [];
  for(var i in obj) str.push(i+'='+encodeURIComponent(obj[i]));
  return str.join('&');
}


var tabqueue = {};


function https(){
  if(localStorage.no_https == 'on'){
    return 'http://'; //idk why someone would want this
  }
  return 'https://';
}

function handleRequest(request, sender, sendResponse){
  console.log(request)
  var instant = (localStorage.instant || 'on') == 'on'; //woot. its called instant because google made google instant.
 

  if(request.action == 'initupload'){
    if(instant){
      var xhr = new XMLHttpRequest();
      xhr.open('GET','https://drag2up.appspot.com/new?'+params({
        host: hostName({
          name:request.name, 
          type: request.type, 
          data:"data:application/octet-stream;base64,VDdIVVQV8WxsZWR3aXRo4HZpbA="
        }),
        size: request.size,
        name: request.name
      }), true);
      xhr.onload = function(){
        var parts = xhr.responseText.split(',');
        sendResponse({
          callback: request.callback,
          url: https()+'drag2up.appspot.com/'+parts[0],
          code: parts[1]
        });
        var cb;
        if(filetable[request.id]) cb = filetable[request.id];
        filetable[request.id] = {
          code: parts[1],
          key: parts[0]
        }
        if(cb) cb();
      }
      xhr.send();
    }else{
      filetable[request.id] = {
        fn: sendResponse,
        callback: request.callback
      }
    }
  }else if(request.action == 'uploaddata'){
    var tab = sender.tab.id;
    chrome.pageAction.show(tab);
    tabqueue[tab] = (tabqueue[tab] || 0) + 1;
    
    function doUpload(){
       uploadData({
          data: request.data,
          name: request.name,
          type: request.type,
          size: request.size
        }, function(url){
        var cb = function(){
          if(instant){
            linkData(request.id, url);
          }else if(filetable[request.id]){ //non-instnat
            filetable[request.id].fn({
              callback: filetable[request.id].callback,
              url: url
            })
          }
          tabqueue[tab]--;
          if(tabqueue[tab] == 0){
            chrome.pageAction.hide(tab);
          }
        };
        
        if(filetable[request.id]) cb(); else filetable[request.id] = cb;
      });
    }
    
    if(request.url){
      if(/^data:/.test(request.url)){
        console.log('data url link');
        //reencode all the data urls because they may be escape encoded and to extract the mime type
        var parts = request.url.match(/^data:(.+),/)[1].split(';');
        var data = request.url.substr(request.url.indexOf(',')+1)
        var mime = parts[0], b64 = parts.indexOf('base64') != -1;
        var bin = '';
        if(b64){
          bin = atob(data)
        }else{
          bin = unescape(data);
        }
        var enc = 'data:'+mime+';base64,'+btoa(bin);
        request.type = mime;
        request.data = enc;
        
        doUpload();
        
      }else{
        var xhr = new XMLHttpRequest();
        xhr.open('GET', request.url);
        xhr.onload = function(){
          var mime = xhr.getResponseHeader('Content-Type')||'application/octet-stream';
          request.type = mime;
          request.data = 'data:'+mime+';base64,'+btoa(xhr.responseText);
          doUpload();
        }
      }
    }else{
      doUpload();
    }
    
  }
  
}


chrome.extension.onRequest.addListener(function(request, sender, sendResponse) {
  setTimeout(function(){
    handleRequest(request, sender, sendResponse)
  }, 0);
});



function fileType(file){
  var text_ext = 'log,less,sass,coffee,yaml,json,md,css,cfm,yaws,html,htm,xhtml,js,pl,php,php4,php3,phtml,py,rb,rhtml,xml,rss,svg,cgi'.split(',');
  if(file.type.indexOf('image/') == 0){
	  //image type
	  return 'image'
	}else if(file.type.indexOf('text/') == 0){
	  return 'text'
	}else if(text_ext.indexOf(file.name.replace(/^.*\.(\w+?)$/,'$1')) != -1){
	  return 'text'
	}else{
	  var src = atob(file.data.replace(/^data.+base64,/i,''));
	  var txt = src.substr(0,512) + src.slice(-512);
	  for(var i = 0, isAscii = true; i < 128; i++){
	    if(txt.charCodeAt(i) > 128){
	     isAscii = false;
	     continue
      }
    }
    if(isAscii && file.size < 1024 * 300) return 'text';
	}
	return 'binary'
}

function hostName(file){
  var typehost = {
    binary: localStorage.binhost || 'hotfile',
	  text: localStorage.texhost || 'gist',
	  image: localStorage.imghost || 'imgur'
	}
	
	var type = fileType(file);
	
	return typehost[type]
}


function uploadData(file, callback){
  //segregate data types, choose blah blah, etc.

	
  var hostfn = {
    hotfile: uploadHotfile,
    gist: uploadGist,
    imgur: uploadImgur,
    imageshack: uploadImageshack,
    dropbox: uploadDropbox,
    pastebin: uploadPastebin,
    cloudapp: uploadCloudApp
  };
  
  var fn = hostfn[hostName(file)];
  if(fn){
    fn(file, callback);
  }else{
    callback('error: no host function for type '+hostName(file)+' for file type '+fileType(file));
  }
  
  //uploadDataURL(file, callback);
}





function uploadDataURL(file, callback){
  //here's the lazy data url encoding system :P
  setTimeout(function(){
    callback(file.data.replace('data:base64','data:text/plain;base64'));
  },1337);
  
  
}




function linkData(id, url){
    var xhr = new XMLHttpRequest();
    xhr.open('GET',https()+'drag2up.appspot.com/update/'+filetable[id].key+'/'+filetable[id].code+'?'+params({
      url: url
    }), true);
    xhr.onload = function(e){
      if(xhr.status != 200){
        //doomsday scenario: error leads to error leading to error leading to effective DoS
        linkData(id, 'error: could not link to upload url because of '+xhr.status+' '+xhr.statusText)
      }
    }
    xhr.onerror = function(e){
      console.log(e)
      linkData(id, 'error: could not link.')
    }
    xhr.send();
}

</script>
